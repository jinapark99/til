# üóìÔ∏è 2025-07-27 (SUN)

> **Today I learned** how the Euclidean and Extended Euclidean algorithms work, how to solve linear Diophantine equations of the form \( ax + by = c \), and how to find modular inverses using these methods. I also learned the mathematical reasoning behind the LCM formula and when modular division is valid.


## üìò Number Theory ‚Äì GCD, Extended Euclidean, LCM, and Modular Inverses

Studied core ideas in number theory including:

- **Euclidean Algorithm**:  
  \[
  \gcd(a, b) = \gcd(b, a \bmod b)
  \]  
  Used to efficiently compute the greatest common divisor. Repeatedly reduces one number using modulus until the other is 0. Time complexity is \(O(\log \min(a, b))\).

- **Extended Euclidean Algorithm**:  
  Finds integers \(x, y\) such that  
  \[
  ax + by = \gcd(a, b)
  \]  
  using recursion. Crucial for solving Diophantine equations and finding modular inverses.

- **Linear Diophantine Equations**:  
  An equation of the form \(ax + by = c\) has integer solutions iff \( \gcd(a, b) \mid c \).  
  Once \(d = \gcd(a, b)\) and \(x_0, y_0\) are such that \(ax_0 + by_0 = d\),  
  then the scaled solution \(x = x_0 \cdot \frac{c}{d}\), \(y = y_0 \cdot \frac{c}{d}\) solves \(ax + by = c\).

- **LCM formula**:  
  \[
  \mathrm{lcm}(a, b) = \frac{ab}{\gcd(a, b)}
  \]  
  Proven by rewriting \(a = dp, b = dq\) where \(d = \gcd(a, b)\), then \(ab/d = dpq\) is a common multiple, and no smaller multiple can be smaller without contradicting the maximality of \(\gcd(a, b)\).

- **Modular Inverses**:  
  An integer \(a^{-1} \mod m\) exists iff \(\gcd(a, m) = 1\).  
  The inverse satisfies:  
  \[
  a \cdot x \equiv 1 \mod m
  \]  
  and can be computed via the Extended Euclidean Algorithm.

- **Modular Division**:  
  \[
  \frac{b}{a} \mod m = b \cdot a^{-1} \mod m
  \]  
  valid **only** if \(a\) and \(m\) are coprime. Division is defined as multiplying by the inverse.

---

## üí° Insight

- In number theory, what looks like simple operations (e.g. division) becomes more subtle when working modulo. You can‚Äôt ‚Äúdivide‚Äù unless an inverse exists.
- The beauty of the extended Euclidean algorithm is that it constructs the inverse (or linear solution) **while computing the GCD** ‚Äî no extra work is needed.
- Modular arithmetic is its own world: no fractions, only integers. And within that world, **inverses and congruences** rule how things work.
- Proving that \(\mathrm{lcm}(a, b) = ab / \gcd(a, b)\) isn‚Äôt just algebraic manipulation ‚Äî it relies on the definition of GCD and divisibility.

---

## üêç Python Practice

Implemented GCD, extended GCD, and modular inverse functions:

```python
# Euclidean Algorithm
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# Extended Euclidean Algorithm
def extended_gcd(a, b):
    if b == 0:
        return a, 1, 0
    d, x1, y1 = extended_gcd(b, a % b)
    return d, y1, x1 - (a // b) * y1

# Solve ax + by = c using extended Euclidean
def diophantine(a, b, c):
    d, x, y = extended_gcd(a, b)
    assert c % d == 0
    factor = c // d
    return x * factor, y * factor

# Modular inverse
def mod_inverse(a, m):
    d, x, y = extended_gcd(a, m)
    if d != 1:
        raise ValueError("Inverse does not exist")
    return x % m
```

---

## üìÑ Problem Summary ‚Äì Modular Inverse Examples

Example 1: \(3^{-1} \mod 11\)  
‚Üí Extended Euclidean gives:  
\[
1 = 4 \cdot 3 - 1 \cdot 11
\Rightarrow 3^{-1} \equiv 4 \mod 11
\]

Example 2: \(7^{-1} \mod 26\)  
‚Üí Solution: \(15\), because \(7 \cdot 15 = 105 \equiv 1 \mod 26\)

Example 3: \(8^{-1} \mod 15\)  
‚Üí Exists and is \(2\), since \(8 \cdot 2 = 16 \equiv 1 \mod 15\)

---

## üß† Concepts Practiced

- ‚úÖ GCD and Euclidean Algorithm
- ‚úÖ Extended Euclidean Algorithm for \(ax + by = d\)
- ‚úÖ Solving Diophantine equations
- ‚úÖ Deriving and proving the LCM formula
- ‚úÖ Understanding and using modular inverses
- ‚úÖ Applying ‚Äúdivision by inverse‚Äù in modular systems

---

## üß† Reflection

- At first, modular inverses felt unintuitive ‚Äî ‚Äúhow do you divide without fractions?‚Äù  
  But understanding that ‚Äúdivision‚Äù is just multiplying by the inverse clarified everything.
- The extended Euclidean algorithm is powerful: not only does it find the GCD, it also gives the tools to solve linear equations and modular problems.
- I now understand why the condition \(\gcd(a, m) = 1\) is essential ‚Äî **it‚Äôs the gatekeeper for division in modular arithmetic**.
- Number theory is abstract, but deeply satisfying when the logic clicks. Modular arithmetic especially feels like learning a new language with its own rules ‚Äî and I‚Äôm finally starting to speak it.
