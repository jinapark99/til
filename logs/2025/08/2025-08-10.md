# ðŸ—“ï¸ 2025-08-10 (SUN)

> **Today I learned**  
> - Designing and creating SQLite database schemas  
> - How to load CSV data into a relational database  
> - Setting up foreign keys and using JOIN  
> - Adding a `Genre` table and `Track.genre_id` column to meet assignment requirements  
> - Solving `database is locked` issues between DB Browser and Python scripts  
> - Understanding ORDER BY behavior and how changing the sort key changes results

---

## ðŸ“˜ Database â€“ Multi-Table Relational SQL

### 1. Creating the database schema
- Created 4 tables: `Artist`, `Genre`, `Album`, `Track`
- Included `genre_id` in the Track table
- All table `id` columns: `INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE`
- Example:
```sql
CREATE TABLE Artist (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    name TEXT UNIQUE
);
CREATE TABLE Genre (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    name TEXT UNIQUE
);
CREATE TABLE Album (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    artist_id INTEGER,
    title TEXT UNIQUE
);
CREATE TABLE Track (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    title TEXT UNIQUE,
    album_id INTEGER,
    genre_id INTEGER,
    len INTEGER, rating INTEGER, count INTEGER
);
```
### 2. Inserting CSV data with Python
- Used INSERT OR IGNORE to prevent duplicates
- Processing order for each row:
  1. Insert artist into Artist table â†’ retrieve artist_id
  2. Insert genre into Genre table â†’ retrieve genre_id
  3. Insert album into Album table (with artist_id) â†’ retrieve album_id
  4. Insert track into Track table (with album_id and genre_id)
- Commit once after all inserts are complete
```python
cur.execute('INSERT OR IGNORE INTO Artist (name) VALUES (?)', (artist,))
cur.execute('SELECT id FROM Artist WHERE name=?', (artist,))
artist_id = cur.fetchone()[0]

cur.execute('INSERT OR IGNORE INTO Genre (name) VALUES (?)', (genre,))
cur.execute('SELECT id FROM Genre WHERE name=?', (genre,))
genre_id = cur.fetchone()[0]

cur.execute('INSERT OR IGNORE INTO Album (title, artist_id) VALUES (?, ?)',
            (album, artist_id))
cur.execute('SELECT id FROM Album WHERE title=?', (album,))
album_id = cur.fetchone()[0]

cur.execute('''INSERT OR REPLACE INTO Track
               (title, album_id, genre_id, len, rating, count)
               VALUES (?, ?, ?, ?, ?, ?)''',
            (name, album_id, genre_id, length, rating, count))
```
### 3. Retrieving data with JOIN
```sql
SELECT Track.title, Artist.name, Album.title, Genre.name
FROM Track
JOIN Genre  ON Track.genre_id  = Genre.id
JOIN Album  ON Track.album_id  = Album.id
JOIN Artist ON Album.artist_id = Artist.id
ORDER BY Artist.name
LIMIT 3;
```
- ORDER BY Artist.name â†’ sorted by artist name
- ORDER BY Artist.name, Track.title â†’ sorted by artist name, then track title

---
## ðŸ’¡ Insight
- database is locked error â†’ happens if DB Browser has the database open while Python tries to write â†’ close DB Browser before running the script
- INSERT OR IGNORE prevents duplicate entries when PK/UNIQUE constraints are violated
- Foreign keys only work if the referenced columns exist (genre_id missing = JOIN fails)
- Changing the ORDER BY clause completely changes the output order
- If the genre is the last column in CSV, it must be read with pieces[6]
---

## âœ… Reflection
Today I practiced the full process of integrating SQLite with Python to transform CSV data into a normalized relational structure.
Initially, the genre_id column was missing from the Track table, causing the assignmentâ€™s query to fail, but adding the Genre table and connecting it resolved the issue.
I also learned that having DB Browser and Python access the same DB file simultaneously causes a database is locked error.
Finally, I saw how JOIN and ORDER BY behavior affect results and confirmed the importance of normalization and proper foreign key setup.
  
