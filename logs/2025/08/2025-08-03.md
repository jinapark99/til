# ğŸ—“ï¸ 2025-08-03 (Sun)

> **Today I learned** how the Extended Euclidean Algorithm not only computes the greatest common divisor (GCD) but also finds integers x and y such that \( ax + by = \gcd(a, b) \). Explored in depth how recursion works, how return values propagate, and how mathematical ideas map directly to code structure.

---

## ğŸ“˜ Number Theory â€“ Extended Euclidean Algorithm

### Studied how and why the Extended Euclidean Algorithm works.

Covered:

- **GCD identity**: \( \gcd(a, b) = ax + by \)
- **Base case**: when \( b = 0 \Rightarrow x = 1, y = 0 \)
- **Recursive relation**:
  - \( x = y' \)
  - \( y = x' - \left\lfloor \frac{a}{b} \right\rfloor \cdot y' \)
- **Why y = 0 in base case**:
  - Mathematically any value would work, but 0 is chosen as a clean starting point for correct recursive buildup.

---

## ğŸ’¡ Insight

- Recursive GCD calls build the result from bottom to top, with each return providing the previous \( x, y \) as input for the next.
- Return values are reassigned: the result from the inner call becomes \( x_1, y_1 \), used to compute the new \( x, y \).
- \( a // b \) must be used instead of \( a / b \) to ensure integer division â€” otherwise recursion may terminate early due to float comparison issues.
- Tuple unpacking allows multiple return values from a function to be cleanly assigned.
- You can pre-swap a and b to avoid handling special cases in recursion.
- Big-O notation represents the upper bound of time complexity: Euclidâ€™s runs in \( O(\log b) \), worst case when input is consecutive Fibonacci numbers.
- Bit operations differ from arithmetic ones: when inputs are \( \beta \)-bit numbers, runtime becomes \( O(\beta^3) \) in terms of actual bit-level work.

---

## ğŸ Python Practice

Final implementation written and debugged from scratch:

```python
def extended_euclid(a, b):
    if b == 0:
        return a, 1, 0
    d, x1, y1 = extended_euclid(b, a % b)
    x = y1
    y = x1 - (a // b) * y1
    return d, x, y

# Input example
a, b = map(int, input("Enter two integers (e.g., 899 493): ").split())
print(extended_euclid(a, b))
```

Tested with input `899 493` â†’ Output: `(29, -6, 11)`, verified by calculating `899*(-6) + 493*11`.

---

## ğŸ§  Concepts Practiced

- âœ… Recursive logic for GCD
- âœ… Tracking and recomputing \( x, y \) using prior return values
- âœ… Python tuple unpacking and input parsing
- âœ… Difference between `//` and `/` in recursion
- âœ… Why base case chooses x = 1, y = 0
- âœ… Mathematical proof of correctness via identity \( ax + by = d \)
- âœ… Bit vs arithmetic complexity: \( O(\beta^3) \) vs \( O(\log b) \)

---

## ğŸ§  Reflection

- Recursive return structure was initially confusing, especially how return values like `d, x1, y1` are computed and used.
- Mixing up `return d, y, x` instead of `return d, x, y` caused subtle bugs due to x/y flipping.
- Switching from `/` to `//` fixed recursion not terminating â€” understanding Pythonâ€™s integer division was critical.
- The algorithm is a powerful example of how mathematical identities can be systematically computed via structured recursion.
