# 🗓️ 2025-08-16 (SAT)

> **Today I learned**  
How to implement and debug a many-to-many relationship in SQL with Python,  
the role of `PRIMARY KEY`, `UNIQUE`, `AUTOINCREMENT`, and how JSON data feeds into DB tables.  
Also worked through a Coursera assignment end-to-end (roster.py → rosterdb.sqlite → XYZZY hash code).

---

## ❓ Q&A Recap

### 1. What is happening here? (Many-to-Many SQL diagram)
- User and Course tables are simple “master lists”.  
- Member table connects User.id ↔ Course.id.  
- JOIN query shows who is student/teacher in which course.  
- ORDER BY sorts results.

### 2. Code walk (roster.py)
- Read JSON → extract name, title, role.  
- Upsert into User, Course.  
- SELECT to get ids.  
- Insert into Member (user_id, course_id, role).  
- Commit.

### 3. Quiz answers
1. Many-to-Many modeling → **junction table (two FKs)**  
2. Cursor is like → **file handle**  
3. Method to run SQL → **execute()**  
4. `?` → **placeholder for variable**  
5. No rows matched → **None**  
6. LIMIT → **only first N rows**  
7. executescript() → **run multiple SQL statements**  
8. OR IGNORE → **avoid duplicates**  
9. Needs → **UNIQUE constraint**

### 4. Assignment instructions
- Download `roster_data.json`, save next to `roster.py`.  
- Run Python → produce `rosterdb.sqlite`.  
- Run SQL queries provided.  
- Submit the `XYZZY + hex(...)` result.

### 5. PRIMARY KEY vs AUTOINCREMENT
- `INTEGER PRIMARY KEY` → auto increment id, may reuse ids.  
- `AUTOINCREMENT` → never reuse ids.  
- Not required for assignment.

### 6. Why UNIQUE?
- Prevent duplicates for User.name and Course.title.  
- Combined with `INSERT OR IGNORE` → skip duplicates.

### 7. Member table explained
```sql
CREATE TABLE Member (
  user_id INTEGER,
  course_id INTEGER,
  role INTEGER,
  PRIMARY KEY (user_id, course_id)
);
```
- Connects User ↔ Course with a role.  
- Composite PK prevents duplicate enrollment.

### 8. Matrix analogy
- M:N relation is like an incidence matrix.  
- DB saves only “1” entries (existing relations) → sparse matrix.

### 9. Student and teacher at the same time?
- Composite PK `(user_id, course_id)` prevents two roles for same person in same course.  
- One user = one role per course.

### 10. Only XYZZY appeared
- Cause: Member.role was NULL → hex(...) NULL → `'XYZZY' || NULL = XYZZY`.  
- Fix: `role = entry[2]`, insert with `VALUES (?,?,?)`, rebuild DB.  
- Also ensure DROP TABLE is executed or delete old DB file.

---

## 📘 Database Schema

```sql
DROP TABLE IF EXISTS User;
DROP TABLE IF EXISTS Course;
DROP TABLE IF EXISTS Member;

CREATE TABLE User (
  id   INTEGER PRIMARY KEY,
  name TEXT UNIQUE
);

CREATE TABLE Course (
  id    INTEGER PRIMARY KEY,
  title TEXT UNIQUE
);

CREATE TABLE Member (
  user_id   INTEGER,
  course_id INTEGER,
  role      INTEGER,
  PRIMARY KEY (user_id, course_id)
);
```

---

## 🐍 Python Code (roster.py loop)

```python
for entry in json_data:
    name  = entry[0]
    title = entry[1]
    role  = entry[2]

    cur.execute('INSERT OR IGNORE INTO User (name) VALUES (?)', (name,))
    cur.execute('SELECT id FROM User WHERE name = ?', (name,))
    user_id = cur.fetchone()[0]

    cur.execute('INSERT OR IGNORE INTO Course (title) VALUES (?)', (title,))
    cur.execute('SELECT id FROM Course WHERE title = ?', (title,))
    course_id = cur.fetchone()[0]

    cur.execute('INSERT OR REPLACE INTO Member (user_id, course_id, role) VALUES (?, ?, ?)',
                (user_id, course_id, role))
```

---

## 🔎 Validation Queries

```sql
-- Check data
SELECT * FROM User LIMIT 5;
SELECT * FROM Course LIMIT 5;
SELECT * FROM Member LIMIT 5;

-- Assignment
SELECT User.name, Course.title, Member.role
FROM User JOIN Member JOIN Course
ON User.id = Member.user_id AND Member.course_id = Course.id
ORDER BY User.name DESC, Course.title DESC, Member.role DESC
LIMIT 2;

SELECT 'XYZZY' || hex(User.name || Course.title || Member.role) AS X
FROM User JOIN Member JOIN Course
ON User.id = Member.user_id AND Member.course_id = Course.id
ORDER BY X LIMIT 1;
```

---

## 🧩 Gotchas I hit (and fixes)

- **Only XYZZY appeared**  
  - Cause: Member.role not inserted → hex(...) was NULL.  
  - Fix: Ensure `role = entry[2]` and use `VALUES (?,?,?)` into Member, rebuild DB.

- **Schema changed but data didn’t**  
  - Cause: Old tables still existed in rosterdb.sqlite.  
  - Fix: Use `DROP TABLE IF EXISTS ...` and rerun loader, or delete `rosterdb.sqlite`.

---

## 💡 Insights

- Composite PKs are perfect to prevent logical duplicates in junction tables.  
- Storing only existing relations in Member is like a sparse matrix representation of M:N.  
- In SQLite, `'text' || NULL -> text` (NULL kills the right side), useful to debug concatenations.

---

## 📝 Reflection

Today I connected matrix thinking to SQL design and solidified why `PRIMARY KEY (user_id, course_id)` is crucial.  
I also debugged why my query returned only `XYZZY` and fixed it by reloading data with role included.  
This gave me confidence in reading assignment instructions carefully and verifying schema/data step by step.
