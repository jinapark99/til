# Python Notes â€” Strings, Encoding, HTTP via Sockets, and OOP Basics

## ðŸ“… Date
2025-08-08 (FRI)

## ðŸ“Œ Today I Learned
- Difference between Python 2 and Python 3 string handling
- How encoding/decoding works when sending/receiving data over a socket
- Quick ASCII/Unicode checks
- Python OOP basics, constructor order, and method call behavior

---

## ðŸ§  Concepts Practiced

### 1. Python 2 vs Python 3 Strings
**Python 2**
- `'text'` â†’ `str` (bytes)
- `u'text'` â†’ `unicode` (Unicode)

**Python 3**
- `'text'` â†’ `str` (Unicode by default)
- `u'text'` â†’ still `str`, the `u` prefix is optional

**Key point:**  
All strings in Python 3 are Unicode internally. Encode/decode is only required at I/O boundaries.

---

### 2. HTTP Request in Python (Raw Socket)

``` python
import socket

mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # IPv4 + TCP
mysock.connect(('data.pr4e.org', 80))

# Unicode string â†’ bytes for sending
cmd = 'GET http://data.pr4e.org/romeo.txt HTTP/1.0\r\n\r\n'.encode()
mysock.send(cmd)

while True:
    data = mysock.recv(512)   # bytes
    if not data:
        break
    # bytes â†’ Unicode string for printing
    print(data.decode())

mysock.close()

Core idea:
encode() â†’ str â†’ bytes (before sending)
decode() â†’ bytes â†’ str (after receiving)
Sockets work with bytes only. Keep internal app data as str (Unicode) and encode/decode at the boundary.
```
---

### 3. ASCII & Unicode Quick Checks
Uppercase G in ASCII decimal: 71
Sequence 108, 105, 115, 116 â†’ "list"

```python
ord('G')   # 71
chr(108)   # 'l'
```

---

### 4. Python OOP Basics
```python
class PartyAnimal:
    def __init__(self):     # Constructor: runs automatically when object is created
        self.x = 0

    def party(self):        # Method: changes state and performs an action
        self.x += 1
        print("So far", self.x)

an = PartyAnimal()
an.party()  # So far 1

How self works:
Refers to the current instance
an.party() is equivalent to PartyAnimal.party(an)
```
---

### 5. Why Constructor First? (Order in Class Definition)
Not a rule â€” Python allows any order, since it parses the entire class body before creating the class object.
Why conventionally put __init__ at the top:
Makes it clear how the object starts (initial attributes)
Most methods depend on attributes set in the constructor
Consistent with many other OOP languages (Java, C++, etc.)
Example (works, but less readable):
```python
class PartyAnimal:
    def party(self):
        self.x += 1
        print("So far", self.x)

    def __init__(self):
        self.x = 0
```
---
### 6. Recommended Class Template
```python
class MyClass:
    """One-line description.

    Optional longer docstring:
    - Attributes
    - Parameters
    - Examples
    """

    DEFAULT_LIMIT = 100

    def __init__(self, limit: int = DEFAULT_LIMIT):
        self.limit = limit
        self.count = 0

    def step(self, n: int = 1) -> int:
        """Increase count by n, capped at limit."""
        self.count = min(self.count + n, self.limit)
        return self.count

    def _reset(self) -> None:
        self.count = 0

    def __repr__(self) -> str:
        return f"MyClass(count={self.count}, limit={self.limit})"
```

### ðŸ’¡ Insights
Internal: Python 3 strings are Unicode
Boundary: Always encode before sending, decode after receiving
Class order: Constructor first is convention, not a strict requirement

---

### ðŸ”„ Reflection
Todayâ€™s notes tied together:

- Low-level networking (sockets)
- How Python handles text internally
- Conventions that improve code readability
I realized that while Python is flexible about method order, sticking to readable conventions makes collaboration easier.
