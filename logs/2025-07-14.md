🗓️ 2025-07-14 (Mon)  
Today I learned how to represent a target sum using signed integers from 1 to n through recursion and backtracking.

---

📘 Algorithm – Representing Target Values with ±1 to ±n

- Explored how to assign + or - signs to each integer from 1 to n to reach a specific target value.
- Learned to use **recursive thinking**, where each level handles the decision for a number n.
- Implemented early **pruning** using math:  
  - If the absolute value is greater than the total sum, or  
  - If `(total - value) % 2 != 0`, the target is unreachable.
- Discovered that `[n]` or `[-n]` in the return statement simply reflects the decision made at that recursion depth.

💡 *Insight:* I was confused at first about why `+n` is chosen when `value >= 0`, and `-n` when `value < 0`.  
By tracing calls manually, I realized that we’re building the final list bottom-up, while the decision (`+n` or `-n`) is made top-down. It felt like leaving breadcrumb choices through the call stack.

---

🐍 Python Practice – Recursive Representation with Backtracking

🧠 Concepts Practiced  
✅ Recursion (working top-down)  
✅ Backtracking (exploring all ± branches)  
✅ Pruning (mathematical constraint filtering)  
✅ Subset Sum with Signs (variation of classic subset sum)

---

💻 My Code
```python
def represent(n, value):
    if n == 0 and value == 0:
        return []

    total = sum(range(1, n + 1))

    if abs(value) > total or (total - value) % 2 != 0:
        return False

    if value >= 0:
        return represent(n - 1, value - n) + [n]
    else:
        return represent(n - 1, value + n) + [-n]


for v in (7, 15, 22, 33, 40, 47):
    print(v, end='')
    result = represent(9, v)
    if not result:
        print(' is not representable')
    else:
        print('=', end='')
        for i in result:
            if i < 0:
                print(f'{i}', end='')
            else:
                print(f'+{i}', end='')
        print()
🧾 Output

csharp
복사
편집
7=+1+2+3-4+5-6+7-8+9
15=+1-2+3+4+5+6-7-8+9
22=+1+2+3+4+5+6+7-8+9
33 is not representable
40 is not representable
47 is not representable
🧠 Reflection
Realized that each recursive level handles one decision and records it as [n] or [-n].

The base case returning [] acts like the "end of the path" that builds back up.

Tracing through represent(3, 2) by hand helped me fully understand how control and memory move in recursion.

I now visualize recursion like a chain of decision snapshots, where each snapshot contributes a piece to the full answer.

This problem deepened my appreciation for how mathematical reasoning (like parity checks) can elegantly simplify recursive searches.
