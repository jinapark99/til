# ğŸ—“ï¸ 2025-07-26 (SAT)

> **Today I learned** how the Euclidean Algorithm finds the greatest common divisor (GCD), why it's efficient, and how the extended Euclidean algorithm expresses GCD as a linear combination of inputs.

---

## ğŸ“˜ Number Theory â€“ Euclidean & Extended Euclidean Algorithm

Studied how to compute \(\gcd(a, b)\) efficiently using repeated division or subtraction.  
Covered:

- **Euclidean Algorithm**:  
  Replace \((a, b)\) with \((b, a \bmod b)\) until \(b = 0\), then return \(a\).  
  Recursive version:  
  \[
  \gcd(a, b) = \gcd(b, a \bmod b)
  \]

- **Why It Works**:  
  \(\gcd(a, b) = \gcd(b, a \bmod b)\) because any common divisor of \(a, b\) also divides their remainder.

- **Efficiency**:  
  Each iteration reduces at least one value by **half or more**, so total steps are at most  
  \[
  \log_2 a + \log_2 b
  \]

- **Extended Euclidean Algorithm**:  
  Also finds integers \(x, y\) such that:  
  \[
  \gcd(a, b) = ax + by
  \]

---

## ğŸ’¡ Insight

- The elegance of the algorithm comes from how it quickly reduces problem size.
- Even when \(a, b\) are very large (hundreds of digits), GCD is computable in milliseconds.
- The â€œextendedâ€ version is not just theoretical â€” itâ€™s used in **modular inverses** and **RSA encryption**.

---

## ğŸ Python Practice

Basic Euclidean Algorithm (recursive):

```python
def gcd(a, b):
    return gcd(b, a % b) if b > 0 else a
```

Extended Euclidean Algorithm:

```python
def extended_gcd(a, b):
    if b == 0:
        return a, 1, 0
    d, x1, y1 = extended_gcd(b, a % b)
    return d, y1, x1 - (a // b) * y1
```

Example:

```python
# Find gcd(30, 12) and x, y such that 30x + 12y = gcd
d, x, y = extended_gcd(30, 12)
print(d, x, y)  # Output: 6, 1, -2  => 30*1 + 12*(-2) = 6
```

---

## ğŸ“„ Problem Summary â€“ Why Itâ€™s Efficient

- At each step, one number drops by **at least half**  
- So max iterations â‰ˆ \(\log_2 a + \log_2 b\)
- Thatâ€™s why GCD of even huge numbers finishes quickly

---

## ğŸ§  Concepts Practiced

- âœ… GCD via Euclidean Algorithm  
- âœ… `%` operator for remainder  
- âœ… Recursive logic for cleaner code  
- âœ… Efficiency proof using logarithmic shrinkage  
- âœ… Linear combination: \( \gcd(a, b) = ax + by \)

---

## ğŸ§  Reflection

- It was fascinating to see that GCD isnâ€™t just a â€œmath trickâ€ but has fast, elegant, real-world implementation.  
- The step-by-step logging helped understand how the numbers shrink each time.  
- The moment I saw \(a \bmod b < a/2\) always holds â€” the efficiency really clicked.  
- Iâ€™ll need to review the extended Euclidean part again later, but the idea of â€œfinding x, yâ€ such that \(ax + by = \gcd\) is super powerful!
