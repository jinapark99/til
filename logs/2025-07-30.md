# ğŸ—“ï¸ 2025-07-30 (WED)

> **Today I learned**  
A deep dive into prime factorization, GCD/LCM computation, coprime identification, recursive list returns in Python, and solving modular congruences using the Chinese Remainder Theorem.  
I didnâ€™t just memorize resultsâ€”I asked â€œwhy?â€ at every step and followed through until I could explain it myself.

---

## ğŸ“˜ Discrete Math & Number Theory

### ğŸ”¹ Prime Numbers
- A number is prime if it has exactly two divisors: 1 and itself.
- Examples:
  - 101 â†’ âœ… Prime  
  - 737 â†’ âŒ Not prime (737 = 11 Ã— 67)

---

### ğŸ”¹ Coprimes (GCD = 1)
- Coprime numbers share no common prime factors.
- Examples:
  - (6, 35) â†’ âœ… Coprime  
  - (10, 15), (15, 35) â†’ âŒ Not coprime (shared factor: 5)

---

### ğŸ”¹ GCD (Greatest Common Divisor)
Given:
- 1980 = \( 2^2 Â· 3^2 Â· 5 Â· 11 \)  
- 1848 = \( 2^3 Â· 3 Â· 7 Â· 11 \)

Then:
\[
\text{GCD}(1980, 1848) = 2^2 Â· 3 Â· 11 = \boxed{132}
\]

âœ… Rule: Use only common prime factors with the **minimum** exponent.

---

### ğŸ”¹ LCM (Least Common Multiple)

\[
\text{LCM}(1980, 1848) = 2^3 Â· 3^2 Â· 5 Â· 7 Â· 11 = \boxed{27720}
\]

âœ… Rule: Use **all** primes that appear in either number with the **maximum** exponent.

ğŸ’¡ Identity:
\[
\text{GCD}(a, b) Ã— \text{LCM}(a, b) = a Ã— b
\]

---

## ğŸ§® Recursive Prime Factorization (Python)

### ğŸ”¸ What it does:
- Takes an integer `m`  
- Returns a list of all its prime factors  
- Uses recursion to break down the number step-by-step

### ğŸ”¸ Full Code

```python
def min_divisor(m):
    for d in range(2, m + 1):
        if m % d == 0:
            return d
        if d * d > m:
            return m

def is_prime(m):
    return m == min_divisor(m)

def factoring(m):
    if is_prime(m):
        return [m]
    else:
        divisor = min_divisor(m)
        factors = factoring(m // divisor)
        factors.append(divisor)
        return factors

# Example test
for i in (7, 60, 1001, 2**32 + 1, 2**64 + 1):
    print(f'Factoring {i}: {factoring(i)}')
```
### â“ What I asked while reading this:
â€œHow can .append() work when we didnâ€™t define factors = []?â€
â†’ Because factoring(...) always returns a list (base case: [m])

â€œBut if if doesnâ€™t run, wonâ€™t the list never get created?â€
â†’ Eventually, the recursive call hits a prime, so [m] is returned and passed upward

â€œIsnâ€™t the return value overwritten?â€
â†’ Yes, but each recursive call has its own scope, and each level gets the result from below and appends to it.

---
## ğŸ”¶ Chinese Remainder Theorem (CRT)
### âœ… Problem type:
Find smallest x such that:
```Python
x â‰¡ r1 mod n1  
x â‰¡ r2 mod n2
```
### ğŸ“ Example:
```python
x â‰¡ 3 mod 5  
x â‰¡ 2 mod 7  
```
â†’ âœ… x = 23 (confirmed manually)
###âš ï¸ Mistake I caught:
Originally thought x = 17, but that fails because 17 â‰¡ 2 mod 5 âŒ
I corrected it by listing values and checking mod conditions myself.

---
## ğŸ’¡ Insight
- Recursion with list return becomes intuitive once you trace how return values are passed up the call stack.
- GCD/LCM rules based on min/max exponents helped clarify why shared or unique primes matter.
- CRTâ€™s value lies in solving multiple congruences togetherâ€”useful in number theory, cryptography, and algorithm design.
- Understanding the why behind every .append() and return helped internalize the logic instead of memorizing syntax.

## ğŸª„ Reflection
- I moved from â€œwhy does this work?â€ to â€œI can explain this myself.â€
- I learned to trust the recursive process more by tracing and visualizing how values are built and returned.
- Spotting a math bug in an example (x = 17) and correcting it boosted my confidence.
- CRT might not be necessary every day, but it opened my eyes to how number theory powers real computation.



