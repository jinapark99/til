# 🗓️ 2025-07-30 (WED)

> **Today I learned**  
A deep dive into prime factorization, GCD/LCM computation, coprime identification, recursive list returns in Python, and solving modular congruences using the Chinese Remainder Theorem.  
I didn’t just memorize results—I asked “why?” at every step and followed through until I could explain it myself.

---

## 📘 Discrete Math & Number Theory

### 🔹 Prime Numbers
- A number is prime if it has exactly two divisors: 1 and itself.
- Examples:
  - 101 → ✅ Prime  
  - 737 → ❌ Not prime (737 = 11 × 67)

---

### 🔹 Coprimes (GCD = 1)
- Coprime numbers share no common prime factors.
- Examples:
  - (6, 35) → ✅ Coprime  
  - (10, 15), (15, 35) → ❌ Not coprime (shared factor: 5)

---

### 🔹 GCD (Greatest Common Divisor)
Given:
- 1980 = \( 2^2 · 3^2 · 5 · 11 \)  
- 1848 = \( 2^3 · 3 · 7 · 11 \)

Then:
\[
\text{GCD}(1980, 1848) = 2^2 · 3 · 11 = \boxed{132}
\]

✅ Rule: Use only common prime factors with the **minimum** exponent.

---

### 🔹 LCM (Least Common Multiple)

\[
\text{LCM}(1980, 1848) = 2^3 · 3^2 · 5 · 7 · 11 = \boxed{27720}
\]

✅ Rule: Use **all** primes that appear in either number with the **maximum** exponent.

💡 Identity:
\[
\text{GCD}(a, b) × \text{LCM}(a, b) = a × b
\]

---

## 🧮 Recursive Prime Factorization (Python)

### 🔸 What it does:
- Takes an integer `m`  
- Returns a list of all its prime factors  
- Uses recursion to break down the number step-by-step

### 🔸 Full Code

```python
def min_divisor(m):
    for d in range(2, m + 1):
        if m % d == 0:
            return d
        if d * d > m:
            return m

def is_prime(m):
    return m == min_divisor(m)

def factoring(m):
    if is_prime(m):
        return [m]
    else:
        divisor = min_divisor(m)
        factors = factoring(m // divisor)
        factors.append(divisor)
        return factors

# Example test
for i in (7, 60, 1001, 2**32 + 1, 2**64 + 1):
    print(f'Factoring {i}: {factoring(i)}')
```
### ❓ What I asked while reading this:
“How can .append() work when we didn’t define factors = []?”
→ Because factoring(...) always returns a list (base case: [m])

“But if if doesn’t run, won’t the list never get created?”
→ Eventually, the recursive call hits a prime, so [m] is returned and passed upward

“Isn’t the return value overwritten?”
→ Yes, but each recursive call has its own scope, and each level gets the result from below and appends to it.

---
## 🔶 Chinese Remainder Theorem (CRT)
### ✅ Problem type:
Find smallest x such that:
```Python
x ≡ r1 mod n1  
x ≡ r2 mod n2
```
### 📍 Example:
```python
x ≡ 3 mod 5  
x ≡ 2 mod 7  
```
→ ✅ x = 23 (confirmed manually)
###⚠️ Mistake I caught:
Originally thought x = 17, but that fails because 17 ≡ 2 mod 5 ❌
I corrected it by listing values and checking mod conditions myself.

---
## 💡 Insight
- Recursion with list return becomes intuitive once you trace how return values are passed up the call stack.
- GCD/LCM rules based on min/max exponents helped clarify why shared or unique primes matter.
- CRT’s value lies in solving multiple congruences together—useful in number theory, cryptography, and algorithm design.
- Understanding the why behind every .append() and return helped internalize the logic instead of memorizing syntax.

## 🪄 Reflection
- I moved from “why does this work?” to “I can explain this myself.”
- I learned to trust the recursive process more by tracing and visualizing how values are built and returned.
- Spotting a math bug in an example (x = 17) and correcting it boosted my confidence.
- CRT might not be necessary every day, but it opened my eyes to how number theory powers real computation.



